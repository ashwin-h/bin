diff --git a/drivers/fpga/machxo2-spi.c b/drivers/fpga/machxo2-spi.c
index a582e0000c97..ad33382b8c9f 100644
--- a/drivers/fpga/machxo2-spi.c
+++ b/drivers/fpga/machxo2-spi.c
@@ -14,9 +14,12 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/spi/spi.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
 
 /* MachXO2 Programming Guide - sysCONFIG Programming Commands */
 #define IDCODE_PUB		{0xe0, 0x00, 0x00, 0x00}
+#define USERCODE_PUB		{0xC0, 0x00, 0x00, 0x00}
 #define ISC_ENABLE		{0xc6, 0x08, 0x00, 0x00}
 #define ISC_ERASE		{0x0e, 0x04, 0x00, 0x00}
 #define ISC_PROGRAMDONE		{0x5e, 0x00, 0x00, 0x00}
@@ -58,11 +61,55 @@
 #define EOVERFL	6 /* overflow error */
 #define ESDMEOF	7 /* SDM EOF */
 
+static struct spi_device *g_alt_spi;
+
 static inline u8 get_err(unsigned long *status)
 {
 	return (*status >> ERRBITS) & ERRMASK;
 }
 
+static int get_ID(struct spi_device *spi, unsigned long *status)
+{
+	struct spi_message msg;
+	struct spi_transfer rx, tx;
+	static const u8 cmd[] = USERCODE_PUB;
+	int ret;
+
+	memset(&rx, 0, sizeof(rx));
+	memset(&tx, 0, sizeof(tx));
+	tx.tx_buf = cmd;
+	tx.len = sizeof(cmd);
+	rx.rx_buf = status;
+	rx.len = 4;
+	spi_message_init(&msg);
+	spi_message_add_tail(&tx, &msg);
+	spi_message_add_tail(&rx, &msg);
+        dev_info(&spi->dev,"Calling spi_sync\n");
+	ret = spi_sync(spi, &msg);
+        dev_info(&spi->dev,"Out of spi_sync ret:%d\n",ret);
+	if (ret)
+		return ret;
+
+	*status = be32_to_cpu(*status);
+
+	return 0;
+}
+
+
+
+static ssize_t show_id(struct kobject *kobj,
+			    	   struct kobj_attribute *attr,
+				   char *buf)
+{
+	unsigned long status;
+        get_ID(g_alt_spi,&status);
+	return sprintf(buf, "0x%x\n", status);
+}
+
+static struct kobj_attribute ashwin_attr = __ATTR(ashwin,
+						0444, show_id,
+						NULL);
+
 static int get_status(struct spi_device *spi, unsigned long *status)
 {
 	struct spi_message msg;
@@ -355,13 +402,25 @@ static const struct fpga_manager_ops machxo2_ops = {
 static int machxo2_spi_probe(struct spi_device *spi)
 {
 	struct device *dev = &spi->dev;
+        g_alt_spi = spi;
 	struct fpga_manager *mgr;
 	int ret;
+        unsigned long id;
+        dev_info(dev,"lattice_fpga:probe called\n");
 
 	if (spi->max_speed_hz > MACHXO2_MAX_SPEED) {
 		dev_err(dev, "Speed is too high\n");
 		return -EINVAL;
 	}
+        dev_info(dev,"lattice_fpga:speed ok\n");
+        ret = sysfs_create_file(kernel_kobj, &ashwin_attr.attr);
+        dev_info(dev,"sysfs_create_file ret:%d\n",ret);
+
+	//ret = get_ID(spi,&id);
+        //dev_err(dev,"lattice_fpga:ID returned :%d\n",ret);
+        //dev_err(dev,"lattice_fpga:ID:0x%lx\n",id);
+
+#if 0
 
 	mgr = fpga_mgr_create(dev, "Lattice MachXO2 SPI FPGA Manager",
 			      &machxo2_ops, spi);
@@ -369,11 +428,10 @@ static int machxo2_spi_probe(struct spi_device *spi)
 		return -ENOMEM;
 
 	spi_set_drvdata(spi, mgr);
-
 	ret = fpga_mgr_register(mgr);
 	if (ret)
 		fpga_mgr_free(mgr);
-
+#endif
 	return ret;
 }
 
diff --git a/drivers/spi/spi-altera.c b/drivers/spi/spi-altera.c
index a5adf0d868fc..7b33109bab62 100644
--- a/drivers/spi/spi-altera.c
+++ b/drivers/spi/spi-altera.c
@@ -20,6 +20,7 @@
 #include <linux/spi/spi.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/pci.h>
 
 #define DRV_NAME "spi_altera"
 
@@ -43,6 +44,21 @@
 #define ALTERA_SPI_CONTROL_IE_MSK	0x100
 #define ALTERA_SPI_CONTROL_SSO_MSK	0x400
 
+#define PCI_VENDOR_ID_PENSANDO          (0x1dd8)
+#define PCI_DEVICE_ID_PENSANDO_SPI      (0x5)
+#define BAR_MASK                        (0x1)
+
+static const struct pci_device_id altera_fpga_spi_ids[] = {
+    {PCI_DEVICE(PCI_VENDOR_ID_PENSANDO, PCI_DEVICE_ID_PENSANDO_SPI)},
+    {0}};
+
+static struct spi_board_info lattice_board_info = {
+            .modalias = "machxo2-slave-spi",
+            .max_speed_hz = 66000000,
+            .bus_num = 0,
+            .chip_select = 0,
+ };
+
 struct altera_spi {
 	void __iomem *base;
 	int irq;
@@ -68,15 +84,19 @@ static void altera_spi_set_cs(struct spi_device *spi, bool is_high)
 	if (is_high) {
 		hw->imr &= ~ALTERA_SPI_CONTROL_SSO_MSK;
 		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
+                dev_info(&spi->dev, "is_high writing 0x%x to ALTERA_SPI_CONTROL\n",hw->imr);
 		writel(0, hw->base + ALTERA_SPI_SLAVE_SEL);
+                dev_info(&spi->dev, "is_high writing 0x%x to ALTERA_SPI_SLAVE_SEL\n",0);
 	} else {
 		writel(BIT(spi->chip_select), hw->base + ALTERA_SPI_SLAVE_SEL);
+                dev_info(&spi->dev, "writing 0x%x to ALTERA_SPI_SLAVE_SEL\n",BIT(spi->chip_select));
 		hw->imr |= ALTERA_SPI_CONTROL_SSO_MSK;
 		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
+                dev_info(&spi->dev, "writing 0x%x to ALTERA_SPI_CONTROL\n",hw->imr);
 	}
 }
 
-static void altera_spi_tx_word(struct altera_spi *hw)
+static void altera_spi_tx_word(struct altera_spi *hw, struct spi_device *spi)
 {
 	unsigned int txd = 0;
 
@@ -91,15 +111,16 @@ static void altera_spi_tx_word(struct altera_spi *hw)
 			break;
 		}
 	}
-
+        dev_info(&spi->dev,"Writing txd with:0x%x\n",txd);
 	writel(txd, hw->base + ALTERA_SPI_TXDATA);
 }
 
-static void altera_spi_rx_word(struct altera_spi *hw)
+static void altera_spi_rx_word(struct altera_spi *hw, struct spi_device *spi)
 {
 	unsigned int rxd;
 
 	rxd = readl(hw->base + ALTERA_SPI_RXDATA);
+        dev_info(&spi->dev, "Got Rx: Rxd:0x%x\n", rxd);
 	if (hw->rx) {
 		switch (hw->bytes_per_word) {
 		case 1:
@@ -125,6 +146,7 @@ static int altera_spi_txrx(struct spi_master *master,
 	hw->count = 0;
 	hw->bytes_per_word = DIV_ROUND_UP(t->bits_per_word, 8);
 	hw->len = t->len / hw->bytes_per_word;
+        dev_info(&spi->dev, "txrx: bytes_per_word-%d len-%d\n",hw->bytes_per_word,hw->len);
 
 	if (hw->irq >= 0) {
 		/* enable receive interrupt */
@@ -132,56 +154,42 @@ static int altera_spi_txrx(struct spi_master *master,
 		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
 
 		/* send the first byte */
-		altera_spi_tx_word(hw);
+		altera_spi_tx_word(hw,spi);
 	} else {
 		while (hw->count < hw->len) {
-			altera_spi_tx_word(hw);
+                        dev_info(&spi->dev, "txrx: count_written-%d len-%d\n",hw->count,hw->len);
+			altera_spi_tx_word(hw,spi);
+                        dev_info(&spi->dev, "txrx: wrote to tx. Waiting for Rx\n"); 
 
 			while (!(readl(hw->base + ALTERA_SPI_STATUS) &
 				 ALTERA_SPI_STATUS_RRDY_MSK))
 				cpu_relax();
+                        dev_info(&spi->dev, "txrx: Rx status ready\n"); 
 
-			altera_spi_rx_word(hw);
+			altera_spi_rx_word(hw,spi);
+                        dev_info(&spi->dev, "txrx: Rx done\n"); 
 		}
+                dev_info(&spi->dev, "txrx: before spi_finalize_current_transfer\n"); 
 		spi_finalize_current_transfer(master);
+                dev_info(&spi->dev, "txrx: after spi_finalize_current_transfer\n"); 
 	}
 
+        dev_info(&spi->dev, "txrx: returning %d\n", t->len);
 	return t->len;
 }
 
-static irqreturn_t altera_spi_irq(int irq, void *dev)
-{
-	struct spi_master *master = dev;
-	struct altera_spi *hw = spi_master_get_devdata(master);
-
-	altera_spi_rx_word(hw);
-
-	if (hw->count < hw->len) {
-		altera_spi_tx_word(hw);
-	} else {
-		/* disable receive interrupt */
-		hw->imr &= ~ALTERA_SPI_CONTROL_IRRDY_MSK;
-		writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
-
-		spi_finalize_current_transfer(master);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int altera_spi_probe(struct platform_device *pdev)
+static int altera_spi_probe(struct pci_dev *pdev, void __iomem *base)
 {
 	struct altera_spi *hw;
 	struct spi_master *master;
-	struct resource *res;
 	int err = -ENODEV;
 
-	master = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));
+	master = spi_alloc_master(&(pdev->dev), sizeof(struct altera_spi));
 	if (!master)
 		return err;
 
 	/* setup the master state. */
-	master->bus_num = pdev->id;
+	master->bus_num = 0; 
 	master->num_chipselect = 16;
 	master->mode_bits = SPI_CS_HIGH;
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
@@ -192,12 +200,7 @@ static int altera_spi_probe(struct platform_device *pdev)
 	hw = spi_master_get_devdata(master);
 
 	/* find and map our resources */
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	hw->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(hw->base)) {
-		err = PTR_ERR(hw->base);
-		goto exit;
-	}
+	hw->base = base; 
 	/* program defaults into the registers */
 	hw->imr = 0;		/* disable spi interrupts */
 	writel(hw->imr, hw->base + ALTERA_SPI_CONTROL);
@@ -205,18 +208,20 @@ static int altera_spi_probe(struct platform_device *pdev)
 	if (readl(hw->base + ALTERA_SPI_STATUS) & ALTERA_SPI_STATUS_RRDY_MSK)
 		readl(hw->base + ALTERA_SPI_RXDATA);	/* flush rxdata */
 	/* irq is optional */
-	hw->irq = platform_get_irq(pdev, 0);
-	if (hw->irq >= 0) {
-		err = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,
-				       pdev->name, master);
-		if (err)
-			goto exit;
-	}
+	hw->irq = -1;
 
 	err = devm_spi_register_master(&pdev->dev, master);
 	if (err)
 		goto exit;
-	dev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);
+	dev_info(&pdev->dev, "base 0x%x, irq %d\n", hw->base, hw->irq);
+
+        if (spi_new_device(master,&lattice_board_info)) {
+            printk(KERN_DEBUG, "altera_fpga:spi_register_board_info ");
+        }
+        else {
+            printk(KERN_DEBUG , "altera_fpga:Failed to register device\n");
+        }
+
 
 	return 0;
 exit:
@@ -224,24 +229,72 @@ static int altera_spi_probe(struct platform_device *pdev)
 	return err;
 }
 
-#ifdef CONFIG_OF
-static const struct of_device_id altera_spi_match[] = {
-	{ .compatible = "ALTR,spi-1.0", },
-	{ .compatible = "altr,spi-1.0", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, altera_spi_match);
-#endif /* CONFIG_OF */
-
-static struct platform_driver altera_spi_driver = {
-	.probe = altera_spi_probe,
-	.driver = {
-		.name = DRV_NAME,
-		.pm = NULL,
-		.of_match_table = of_match_ptr(altera_spi_match),
-	},
+// Initialize all the SPI controllers on a PCI device
+static int
+altera_fpga_spi_probe(struct pci_dev *pdev, const struct pci_device_id *id) {
+    int                      ret      = 0;
+    void __iomem *base_addr;
+    void __iomem *const *tbl;
+    uint32_t fpga_id;
+
+    // Enable PCI device
+    ret = pcim_enable_device(pdev);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to enable OpenCores I2C PCI device rc=%d\n",
+                ret);
+        return -1; 
+    }
+
+    // Set the device as bus master for MSI to work
+    if (!pdev->is_busmaster) {
+        pci_set_master(pdev);
+    }
+
+    // Request BAR and iomap it
+    ret =
+        pcim_iomap_regions(pdev, BAR_MASK, dev_driver_string(&pdev->dev));
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to request and iomap PCI region rc=%d\n",
+                ret);
+        return -1; 
+    }
+
+    // Retrive BAR 0
+    tbl       = pcim_iomap_table(pdev);
+    base_addr = tbl[0];
+    dev_info(&pdev->dev, "altera_fpga:base_addr=0x%x\n",base_addr);
+    fpga_id = ioread32(base_addr);
+    dev_info(&pdev->dev, "altera_fpga:fpga_id=0x%x\n",fpga_id);
+    base_addr = ((char*)base_addr+1120);
+    dev_info(&pdev->dev, "altera_fpga:base_addr after adjustment =0x%x\n",base_addr);
+
+    return altera_spi_probe(pdev, base_addr);
+}
+
+static void
+altera_fpga_spi_remove(struct pci_dev *pdev) {
+
+}
+
+static struct pci_driver altera_fpga_driver = {
+    .name        = "altera_fpga",
+    .id_table    = altera_fpga_spi_ids,
+    .probe       = altera_fpga_spi_probe,
+    .remove      = altera_fpga_spi_remove,
 };
-module_platform_driver(altera_spi_driver);
+
+static int __init
+           altera_fpga_spi_init(void) {
+    return pci_register_driver(&altera_fpga_driver);
+}
+
+static void __exit
+            altera_fpga_spi_exit(void) {
+    pci_unregister_driver(&altera_fpga_driver);
+}
+
+module_init(altera_fpga_spi_init);
+module_exit(altera_fpga_spi_exit);
 
 MODULE_DESCRIPTION("Altera SPI driver");
 MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
